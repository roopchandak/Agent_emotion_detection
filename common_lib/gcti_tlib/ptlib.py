#
#                  === Access to T-Library ===
#
#
# - Implementsconvenient interface to T-Library
# - Define classes:
#   - Event
#  - TServer0
#    - TServer0 instance is T-Server client; several TServer0 instances can be used at the same time
#    - Methods are T-library functions + some suplementary functions
#    - In function parametes all  enumeration values are substituted by EnumElem

import types
import string
import copy
import time
import re


from common.common import *
from com_tlib import *
from common.common_enum import *
from common.enum import *
from tlib import *
from test_view import PrintViewA

from threading import Lock

global TLock
TLock = Lock()
#=============== Event ===================

# Raw event - event generated by T-Library

_emptyRawEvent = (
  0,                                    #  ("Event"             , EventName),
  0,                                    #  ("Server"            , None),
  0,                                    #  ("ReferenceID"       , None),
  None,                                 #  ("HomeLocation"      , None),
  None,                                 #  ("CustomerID"        , None),
  NoConnID,                             #  ("ConnID"            , None),
  NoConnID,                             #  ("PreviousConnID"    , None),
  0,                                    #  ("CallID"            , None),
  0,                                    #  ("NodeID"            , None),
  0,                                    #  ("NetworkCallID"     , None),
  0,                                    #  ("NetworkNodeID"     , None),
  ((None,None),(None,None)),            #  ("CallHistory"       , None),
  0,                                    #  ("CallType"          , CallType),
  0,                                    #  ("CallState"         , CallState),
  None,                                 #  ("AgentID"           , None),
  0,                                    #  ("WorkMode"          , None),
  0,                                    #  ("ErrorCode"         , None),
  None,                                 #  ("ErrorMessage"      , None),
  0,                                    #  ("FileHandle"        , None),
  None,                                 #  ("CollectedDigits"   , None),
  0,                                    #  ("LastCollectedDigit", None),
  None,                                 #  ("ThisDN"            , None),
  None,                                 #  ("ThisQueue"         , None),
  0,                                    #  ("ThisTrunk"         , None),
  0,                                    #  ("ThisDNRole"        , PartyRole),
  None,                                 #  ("OtherDN"           , None),
  None,                                 #  ("OtherQueue"        , None),
  0,                                    #  ("OtherTrunk"        , None),
  0,                                    #  ("OtherDNRole"       , PartyRole),
  None,                                 #  ("ThirdPartyDN"      , None),
  None,                                 #  ("ThirdPartyQueue"   , None),
  0,                                    #  ("ThirdPartyTrunk"   , None),
  0,                                    #  ("ThirdPartyDNRole"  , PartyRole),
  None,                                 #  ("DNIS"              , None),
  None,                                 #  ("ANI"               , None),
  None,                                 #  ("CallingLineName"   , None),
  None,                                 #  ("CLID"              , None),
  0,                                    #  ("InfoType"          , None),
  0,                                    #  ("InfoStatus"        , None),
  0,                                    #  ("TreatmentType"     , TreatmentType),
  0,                                    #  ("RouteType"         , None),
  None,                                 #  ("ServerVersion"     , None),
  0,                                    #  ("ServerRole"        , None),
  NullMask,                             #  ("Capabilities"      , None),
  None,                                 #  ("UserData"          , None),
  None,                                 #  ("Reasons"           , None),
  None,                                 #  ("Extensions"        , None),
  (0,0),                                #  ("Time"              , None),
  0,                                    #  ("RawData"           , None),
  None,                                 #  ("AccessNumber"      , None),
  0,                                    #  ("XRouteType"        , None),
  0,                                    #  ("XReferenceID"      , None),
  None,                                 #  ("TreatmentParameters", None),
  None,                                 #  ("Place"             , None),
  0,                                    #  ("Timeout"           , None),
  0,                                    #  ("MediaType"         , MediaType),
  0,                                    #  ("LocationInfo"      , LocationInfo),
  0,                                    #  ("MonitorNextCallType", None),
  0,                                    #  ("PrivateEvent"      , None),
  0,                                    #  ("ApplicationData"   , None)
  0,                                    #  ("TEventFormat"      , None),
  0,                                    #  ("DBID"                         , None),                      # 61
  0,                                    #  ("OtherDBID"                    , None),                      # 62
  0,                                    #  ("ThirdPartyDBID"               , None),                      # 63
  None,                                 #  ("DN"                           , None),                      # 64
  None,                                 #  ("DialedNumber"                 , None),                      # 65
  NoConnID,                             #  ("OriginConnID"                 , None),                      # 66
  NoConnID,                             #  ("RefConnID"                    , None),                      # 67
  NoConnID,                             #  ("NewConnID"                    , None),                      # 68
  0,                                    #  ("Reliability"                  , None),                      # 69
  None,                                 #  ("PartyID"                      , None),                      # 70
  0,                                    #  ("PartyType"                    , None),                      # 71
  0,                                    #  ("PartyState"                   , None),                      # 72
  0,                                    #  ("RefParty"                     , None),                      # 73
  None,                                 #  ("CtrlParty"                    , None),                      # 74
  None,                                 #  ("RemoteLoc"                    , None),                      # 75
  0,                                    #  ("RemoteParty"                  , None),                      # 76
  None,                                 #  ("ServerXCapabilities"          , None),                      # 77
  0,                                    #  ("NetworkCallState"             , NetworkCallState),          # 78
  0,                                    #  ("NetworkDestState"             , NetworkDestState),          # 79
  None,                                 #  ("NetworkDestDN"                , None),                      # 80
  None,                                 #  ("NetworkOrigDN"                , None),                      # 81
  0,                                    #  ("ClientID"                     , None),                      # 82
  None,                                 #  ("CallUUID"                     , None),                      # 83
  None,                                 #  ("NewCallUUID"                  , None),                      # 84
  None,                                 #  ("OrigCallUUID"                 , None),                      # 85
  None,                                 #  ("RefCallUUID"                  , None),                      # 86
  None,                                 #  ("PartyUUID"                    , None),                      # 87
  None,                                 #  ("ISLinkList"                   , None),                      # 88
  (0,0),                                #  ("ServerStartTime"              , None),                      # 89
  0,                                    #  ("EventSequenceNumber"          , None),                      # 90
  0,                                    #  ("Cause"                        , Cause),                     # 91
  None,                                 #  ("LastTransferConnID"           , None),                      # 92
  0,                                    #  ("SubscriptionOperation"        , SubscriptionOperationType), # 93
  None,                                 #  ("SubscriptionID"               , None),                      # 94
  0,                                    #  ("LocalCallType"                , CallType),                  # 95
  0                                     #  ("PropagatedCallType"           , CallType),                  # 96
  )


class Event:
  """Represent TEvent + extra fields extracted in event->raw_data.
  See Genesys TLibrary doc for TEvent description"""

  zeroExpr = re.compile(r"^\000*$")   # Match array of 0 bytes

  eventEnumTbl = ( # Table used to create Event from raw T-Library event.
                   # consist of (attr name, attr enum, function to get attr, default value, additional func to transform value)
    ("Event"                        , EventName),     #  0
    ("Server"                       , None),          #  1
    ("ReferenceID"                  , None),          #  2
    ("HomeLocation"                 , None),          #  3
    ("CustomerID"                   , None),          #  4
    ("ConnID"                       , None),          #  5
    ("PreviousConnID"               , None),          #  6
    ("CallID"                       , None),          #  7
    ("NodeID"                       , None),          #  8
    ("NetworkCallID"                , None),          #  9
    ("NetworkNodeID"                , None),          #  10
    ("CallHistory"                  , None),          #  11
    ("CallType"                     , CallType),      #  12
    ("CallState"                    , CallState),     #  13
    ("AgentID"                      , None),          #  14
    ("WorkMode"                     , None),          #  15
    ("ErrorCode"                    , None),          #  16
    ("ErrorMessage"                 , None),          #  17
    ("FileHandle"                   , None),          #  18
    ("CollectedDigits"              , None),          #  19
    ("LastCollectedDigit"           , None),          #  20
    ("ThisDN"                       , None),          #  21
    ("ThisQueue"                    , None),          #  22
    ("ThisTrunk"                    , None),          #  23
    ("ThisDNRole"                   , PartyRole),     #  24
    ("OtherDN"                      , None),          #  25
    ("OtherQueue"                   , None),          #  26
    ("OtherTrunk"                   , None),          #  27
    ("OtherDNRole"                  , PartyRole),     #  28
    ("ThirdPartyDN"                 , None),          #  29
    ("ThirdPartyQueue"              , None),          #  30
    ("ThirdPartyTrunk"              , None),          #  31
    ("ThirdPartyDNRole"             , PartyRole),     #  32
    ("DNIS"                         , None),          #  33
    ("ANI"                          , None),          #  34
    ("CallingLineName"              , None),          #  35
    ("CLID"                         , None),          #  36
    ("InfoType"                     , AddressInfo),   #  37
    ("InfoStatus"                   , None),          #  38
    ("TreatmentType"                , TreatmentType), #  39
    ("RouteType"                    , None),          #  40
    ("ServerVersion"                , None),          #  41
    ("ServerRole"                   , None),          #  42
    ("Capabilities"                 , None),          #  43
    ("UserData"                     , None),          #  44
    ("Reasons"                      , None),          #  45
    ("Extensions"                   , None),          #  46
    ("Time"                         , None),          #  47
    ("RawData"                      , None),          #  48
    ("AccessNumber"                 , None),          #  49
    ("XRouteType"                   , None),          #  50
    ("XReferenceID"                 , None),          #  51
    ("TreatmentParameters"          , None),          #  52
    ("Place"                        , None),          #  53
    ("Timeout"                      , None),          #  54
    ("MediaType"                    , MediaType),     #  55
    ("LocationInfo"                 , LocationInfo),  #  56
    ("MonitorNextCallType"          , MonitorNextCallType),   #  57
    ("PrivateEvent"                 , None),          #  58
    ("ApplicationData"              , None),
    ("TEventFormat"                 , None),
    ("DBID"                         , None),
    ("OtherDBID"                    , None),
    ("ThirdPartyDBID"               , None),
    ("DN"                           , None),
    ("DialedNumber"                 , None),
    ("OriginConnID"                 , None),
    ("RefConnID"                    , None),
    ("NewConnID"                    , None),
    ("Reliability"                  , None),
    ("PartyID"                      , None),
    ("PartyType"                    , None),
    ("PartyState"                   , None),
    ("RefParty"                     , None),
    ("CtrlParty"                    , None),
    ("RemoteLoc"                    , None),
    ("RemoteParty"                  , None),
    ("ServerXCapabilities"          , None),
    ("NetworkCallState"             , NetworkCallState),
    ("NetworkDestState"             , NetworkDestState),
    ("NetworkDestDN"                , None),
    ("NetworkOrigDN"                , None),
    ("ClientID"                     , None),
    ("CallUUID"                     , None),
    ("NewCallUUID"                  , None),
    ("OrigCallUUID"                 , None),
    ("RefCallUUID"                  , None),
    ("PartyUUID"                    , None),
    ("ISLinkList"                   , None),
    ("ServerStartTime"              , None),
    ("EventSequenceNumber"          , None),
    ("Cause"                        , Cause),
    ("LastTransferConnID"           , None),
    ("SubscriptionOperation"        , SubscriptionOperationType),
    ("SubscriptionID"               , None),
    ("LocalCallType"                , CallType),
    ("PropagatedCallType"           , CallType),

  )


  def __init__(self, rawEvent = None):
    """ Create Event instance from rawEvent returned by tlib.ReadEvent(...)"""

    i = 0

    for (nm, en) in self.eventEnumTbl:

      if rawEvent:

        if en:
          setattr(self, nm, ValToEnumElem(en, rawEvent[i]))
        else:
          setattr(self, nm, rawEvent[i])
      else:
        pass

      i = i+1

    self.marked = 0

  def EventName(self):
    return self.Event

  def fldToStr(self, fldName):
    """ String representation on Event field"""
    str = ""
    try:
      val = getattr(self, fldName)
    except AttributeError:
      return ""
    if val  == -1: # means that integer field is absent
      str = ""

    elif fldName in ("ConnID", "PreviousConnID", "OriginConnID",  "RefConnID", "NewConnID", "PartyID", "LastTransferConnID"):

      #if val <> NoConnID:
      str = ConnIDToStr(val)
      #else: str = ""
    elif fldName == "PartyState":
      if val:
        vals = [val & 0xF, val & 0xF0, val & 0xF00, val & 0xF0000]
        for v in vals:
          if v:
            val = ValToEnumElem(TPartyState, v)
            str = str + " + " + `val`
        if str: str = str [3:]

    elif fldName == "Capabilities" and not self.zeroExpr.match(val) :
        capabilityMask = []
        bitMask = []
        for i in range(0,len(self.Capabilities)):
          bitMask = bitMask + [ord(self.Capabilities[i])]
        for each in EventName.members:
          if bitMask[each/8]&(1<<(each%8)):
            capabilityMask  = capabilityMask   + [each]
        #str = capabilityMask
        str = "[...]"
    elif fldName in ("Time","ServerStartTime"):
      if val <> (-1, -1):
        str = time.strftime("%m/%d/%y %H:%M:%S", time.localtime(val[0])) + ".%4d"%(int(round(float(val[1])/1000000, 4)*10000))

    elif fldName in ("UserData", "Reasons"):
      if val:
        str = ""
        if val.keys():
          str = str + "%s :%s\n" %(val.keys()[0], val[val.keys()[0]])
        if len(val.keys()) > 1:
          for key in val.keys()[1:]:
            str = str + "                    %s :%s\n" %(key, val[key])
    elif fldName  == "Extensions":
      doNotPrint = False

      if val:
        str = ""
        if val.keys():
          key = val.keys()[0]
          if val[key] and type(val[key]) == type(""):
            for sym in val[key]:
              if ord(sym) < 32:
                doNotPrint = True
                break
          if not doNotPrint:
            str = str + "%s :%s\n" %(key, val[key])
          else:
            str = str + "%s :%s\n" %(key, "...bin...")
          if len(val.keys()) > 1:
            for key in val.keys()[1:]:
              if val[key] and type(val[key] ) == type(""):

                for sym in val[key]:
                  if ord(sym) < 32:
                    doNotPrint = True
                    break
              if not doNotPrint:
                str = str + "                    %s :%s\n" %(key, val[key])
              else:
                str = str + "%s :%s\n" %(key, "...bin...")
    elif fldName == "EventSequenceNumber":
      str = "%016x"%val
    else:
      str = `val`

    if (not val or
        fldName == "LocationInfo"                and  val == LocationInfo.AllLocations     or
        fldName == "Capabilities"                and  self.zeroExpr.match(val)             or
        fldName == "CallHistory"                 and  val == EmptyCallHistory              or
        fldName == "RawData"                                                               or
        fldName == "MediaType"                   and  val == MediaType.Voice               or
        str     == "Unknown"                     and  fldName != "CallState"               or

        fldName == "MonitorNextCallType"         and  val == MonitorNextCallType.MonitorOneCall  and
          self.Event not in (EventName.MonitoringNextCall,      EventName.MonitoringCancelled) or
        fldName == "PartyType"                   and  self.Event not in CallMonitoringEvents.members or        fldName == "CallState"                   and  val == CallState.Ok  and
          self.Event not in (EventName.Queued,      EventName.Abandoned,      EventName.Ringing,
                             EventName.Dialing,     EventName.NetworkReached, EventName.DestinationBusy,
                             EventName.Established, EventName.Released,       EventName.Held,
                             EventName.Retrieved,   EventName.PartyChanged,   EventName.PartyAdded,
                             EventName.PartyDeleted,EventName.RouteRequest,   EventName.RouteUsed,
                             EventName.Diverted,    EventName.UserEvent)

       ):
      if fldName == "InfoStatus" and self.Event in (EventName.Registered, EventName.AddressInfo) : return str # even 0
      return ""

    else:
      return str


  def __repr__(self):
    str = ""

    for (nm, en) in self.eventEnumTbl:
      s = self.fldToStr(nm)
      if s: str = str + "%-17s = %s\n" % (nm, s)
    return str


  def __str__(self):
    str = "Event = %-17s\n" % self.Event

    if self.Event == EventName.Error:
      s = self.fldToStr("ErrorMessage");
      if s:  s = "ErrorMessage = %-17s\n"   % s;  str = str + s

    s = self.fldToStr("Time");
    if s: s = "Time = %-17s\n"  % s; str = str+s

    s = self.fldToStr("ThisDN");
    if s: s = "ThisDN = %-17s\n"  % s; str = str+s

    s = self.fldToStr("OtherDN");
    if s: s = "OtherDN = %-17s\n" % s; str = str+s

    s = self.fldToStr("CallState");
    if s: s = "CallState = %-17s\n" % s; str = str+s

    s = self.fldToStr("ConnID");
    if s:  s = "ConnID = %-17s\n"   % s;  str = str+s

    s = self.fldToStr("ReferenceID");
    if s: s = "RefID = %-17s\n" % s; str = str+s

    s = self.fldToStr("UserData");
    if s: s = "UserData = %-17s\n" % s; str = str+s

    s = self.fldToStr("EventSequenceNumber");
    if s: s = "EventSequenceNumber = %-17s\n" % s; str = str+s
    return str


  def rawEvent(self):
    """Create structure to pass to tlib.SendEvent(...), tlib.SendUserEvent(...)"""

    rev = list(copy.deepcopy(_emptyRawEvent))

    i = 0
    val = None
    for field in rev:
      (nm, en) = self.eventEnumTbl[i]
      if hasattr(self, nm):
        if en:
          rev[i] = getattr(self, nm).val
        else:
          rev[i] = getattr(self, nm)
      i = i + 1
    return tuple(rev)

TEvent = Event

#=========================================
def CreateTserverClient(host, port):
  """Create simple tserver client connected to host, port"""
  ts = TServer0()
  ts.OpenServerEx(host, port, "tserver_client", "")
  ts.WaitEvent(eventName = "LinkConnected")
  return ts

#=============== TServer0 ================

_defaulTimeout = 20                    # Defaul timeout for event wating

class TServer0:
  """Implement TServer client. Provides interface to TServer using TLibrary functions"""
  TEvent = Event
  def __init__(self, appName = ""):

    self.uniqClientID = appName
    self.fd = -1
    self.connected = 0
    self.reconnecting = 0
    self.refID = 0
    self.registeredAll = 0

    self.defaulTimeout = _defaulTimeout
    self.eventQueue = []              # List of unhandled events
    self.callMonitoringDN = None
    self.appVersion = ""
    self.previousEventSequenceNumber = 0
    self.IgnoredEventList = []        #***370 Events which must be ignored

    self.connIDData = {}

    self.ActionOnUnexpectedEvent = None # Actions. must be a functions of form:   action(number, event)
    self.linkConnected = 1 # we assume that whe server is created the link is connected
    self.ReconnectProcedure = None
    self.ignoreUnexpectedEventsOnDNs = []   #list of pairs (number, eventName)
    self.mask = copy.copy(EventName.members)
    self.printBuffer = {}
    self.registeredDNs = []
    self.master = Any()
    if GetOption("TrackCallUUID"):
      self.callUUIDs = []
      self.callUUIDsFileName = "%s\\callUUIDs.txt"%GetOption("TestResultFolder")
      f = open(self.callUUIDsFileName, "w") #clean file
      f.close()
    self.allConnIDs = {}
    self.tsLock = Lock()


  def ConnectionError(self):
    import traceback
    self.fd = -1
    self.connected = 0
    printStackFlag = GetOption("PrintStackFlag")
    SetOption("PrintStackFlag", 0)
    Error("TServer disconnected")
    traceback.print_stack(limit = 50, file = sys.stdout)
    SetOption("PrintStackFlag", printStackFlag)
    if self.reconnecting: return
    if self.ReconnectProcedure:
      self.ReconnectProcedure()
    else:
      ConnectionError("TServer")

  def setMaster(self, master):
    self.master = master

  def SetDefaultTimeout(self, timeout):
    self.defaulTimeout = timeout

  def numberRegistered(self, number):
    if GetOption("WaitEventsOnUnregisteredDNs") or self.registeredAll: return 1
    if number in self.registeredDNs or not number:
      return 1
    #print "number %s not registered" %number
    return 0

  def OpenServerEx(self, host, port, appName, appPassword, openMode = OpenMode.Sync):
    """Open connection to TServer using TOpenServerEx function
    Return handle on success, raises FatalError exception on fail"""
    self.previousEventSequenceNumber = 0
    self.fd = TOpenServerEx(host, int(port), appName, appPassword)
    if self.fd <= 0:
      OpenError("Can't open TServer %s " % str((host, port)))
    return self.fd

  def OpenServer(self, sectionName, appName, appPassword, openMode = OpenMode.Sync):
    """Open connection to TServer using TOpenServer function
    Return handle on success, raises FatalError exception on fail"""
    self.previousEventSequenceNumber = 0
    self.fd = TOpenServer(sectionName, appName, appPassword, openMode.val)
    if self.fd <= 0:
      OpenError("Can't open TServer %s " % str(sectionName))
    return self.fd

  def OpenServerX(self, connParam, appName = "", appPassword = ""):
    """connParam - <xkvlist> string returned by ConfPrepareClient or ConfPrepareConnParams
    Return handle on success, raises FatalError exception on fail"""
    self.previousEventSequenceNumber = 0
    self.fd = TOpenServerX(connParam, appName, appPassword)
    if self.fd <= 0:
     OpenError("Can't open TServer %s " %connParam)
    return self.fd


  def CloseSocket(self):

    """Close connection to TServer"""

    if self.fd < 0: return
    res = 0
    PrintLog("Closing server %d" %self.fd)
    res = TCloseServer(self.fd)
    if res < 0:                       # 0 is OK
      self.ConnectionError()

    PrintLog("remaining event queue %s" %self.eventQueue)
    self.eventQueue = []              # List of unhandled events
    self.IgnoredEventList = []        #***370 Events which must be ignored
    self.connIDData = {}
    self.fd = -2

    return res

  def setBeforeLastConnID(self, number, connID):
    """Set previous ConnID """
    if self.connIDData.has_key(number):
      l = self.connIDData[number]
      l[1] = connID
      self.connIDData[number] = copy.copy(l)


  def setLastConnID(self, number, connID):
    """Set last ConnID from 'ringing' event"""
    if self.connIDData.has_key(number):
      l = self.connIDData[number]
      l[0] = connID
      self.connIDData[number] = copy.copy(l)
    else:
      self.connIDData[number] = [connID, connID]


  def getBeforeLastConnID(self, number):
    """Return previous ConnID for number"""
    if self.connIDData.has_key(number):
      return self.connIDData[number][1]
    else:
      return NoConnID


  def getLastConnID(self, number):
    """Return last ConnID for number"""
    if self.connIDData.has_key(number):
      return self.connIDData[number][0]
    else:
      return NoConnID


  #-----------------------------------------

  def WaitEvent(self, numbers = [], eventName = None, timeout = None, keyFields = ["ThisDN"]):
    """ Wait event from T-Server for this client and return the event as result.

    Params:
      numbers   - value(s) of keyFields. Normally numbers is ThisDN value
      eventName - string EventName or list of EventNames
      timeout   - integer
      keyFields - list of TEvent fields

      Note:  keyFields[i] and numbers[i] should make pairs key:value, example:
        WaitEvent(numbers = ['24500'], keyFields = ['ThisDN']) # event with ThisDN = 24500 is expected
        WaitEvent(numbers = ['24500', '1'], keyFields = ['ThisDN']) # event with ThisDN = 24500 and 'PartyType' = 1 is expected

        Normally numbers is ThisDN value

    Return      - Event / None (there was no event during timeout)


    There are several types of call:
      WaitEvent()              - wait first event for any number
      WaitEvent('24500')        - wait first event for definite number
      WaitEvent('24500', 'Ringing') - wait definite event for definite number
      WaitEvent('24500', ['Ringing', 'Established', ...]) - wait any event from event set
                                                 for definite number

    If timeout not defined then self.defaulTimeout is used.
    If during timeout required event wasn't received then None returned.
    If during event waiting unexpected event was received,
    then self.ActionOnUnexpectedEvent is called and the event is refused.
    """
    #PrintLog("ptlib::WaitEvent %s timeout %s eventName %s numbers %s keyFields %s" %(self.fd, timeout, eventName, numbers, keyFields))
    #for e in self.eventQueue:
    #  PrintLog(e.Event)
    if GetOption("MT"):
      self.tsLock.acquire()
    if self.fd == -1:
      if GetOption("MT"):
        self.tsLock.release()
      return        #non-monitored tserver
    if type(numbers) is not types.ListType:
      if numbers:
        numbers = [numbers]
      else:
        numbers = []
    removed = 0
    origNums = copy.copy(numbers)
    try:
      ind = keyFields.index("ThisDN")
      number = numbers[ind]
      if number != "Empty" and not self.numberRegistered(number) and eventName not in ("Error", "Registered", "Unregistered", "AddressInfo", "PartyInfo"):
        if eventName:
          PrintLog("skipping event %s on not registered dn %s" %(eventName, number))
        if GetOption("MT"):
          self.tsLock.release()

        return
    except IndexError:
      pass

    if eventName and (type(eventName) <> type([])):
      eventName = [eventName]
    if eventName == None: eventName = []
    eventNameExisted = None
    if eventName:
      eventNameExisted = 1

      for ev in eventName:
        if not self.MaskIsSet(ev):
          eventName.remove(ev)

    if not eventName and eventNameExisted:

      if GetOption("MT"):
        self.tsLock.release()
      time.sleep(0.5)
      return

    if not timeout:
      timeout = self.defaulTimeout

    i = 0
    found = 0
    eventToPutBackList = []
    pairs = []
    i = 0
    for keyField in keyFields:
      try:
        number = numbers[i]
      except IndexError:
        number = None
      pair = (number,  keyField)
      i = i + 1
      pairs.append(pair)
    i = 0

    while i < len(self.eventQueue):   # Search event in self.eventQueue

      ev = self.eventQueue[i]

      if ev.Event == "ServerDisconnected":
        self.ConnectionError()
      elif ev.Event == "LinkConnected":
        self.linkConnected = 1
      elif ev.Event == "LinkDisconnected":
        self.linkConnected = 0
      elif ev.Event == "Registered" and ev.ThisDN not in self.registeredDNs:
        self.registeredDNs.append(ev.ThisDN)
      elif ev.Event == "Unregistered" and ev.ThisDN in self.registeredDNs:
        self.registeredDNs.remove(ev.ThisDN)
      #print "self.linkConnected = %s" %self.linkConnected
      condition = 1
      match = 0
      for pair in pairs:
        number, keyField = pair
        res = getattr(ev, keyField)

        if keyField == "Extensions" and res and number:
          match = 1
          for k in number.keys():
            if not res.has_key(k):
              match = 0
            else:
              if number[k] != res[k]:
                match = 0


        if not ((number == None) or (number == getattr(ev, keyField)) or (number == "Empty" and not getattr(ev, keyField)) or (keyField == "Extensions" and match != 0)):
          condition = 0
          break
      if ev.Event == "LinkDisconnected" and ev.Event not in eventName:
        condition = 1 # we need actionOnUnexpected
      if condition:
        del self.eventQueue[i]

        if (not eventName) or (ev.Event in eventName):
          found = 1
          break


        flagUnexpected = 1

        if ev.Event in (EventName.RemoteConnectionSuccess, EventName.RemoteConnectionFailed, EventName.NetworkCallStatus):
          eventToPutBackList.insert(0, ev)
          flagUnexpected = 0

        if str(ev.Event) in CallMonitoringEvents.members or str(ev.Event) == "TransactionStatus" \
          or str(ev.Event) == "PrivateInfo" \
          and ev.Event not in eventName:
          eventToPutBackList.insert(0, ev)
          flagUnexpected = 0


        for e in self.IgnoredEventList:
          if (e[0] == ev.ThisDN) and (e[1] == ev.Event):
            self.IgnoredEventList.remove(e)
            flagUnexpected = 0
            found = 1
            break

        if flagUnexpected:
          for pair in self.ignoreUnexpectedEventsOnDNs:
            if pair[0] == number and pair[1] == ev.Event:
              flagUnexpected = 0
              break


        if not isinstance(self.master, Any) and self.master.ActionOnUnexpectedEvent and flagUnexpected:
          id = ""
          if str(ev.Event) in CallMonitoringEvents.members:
            id = "CallMonitoring"
          elif str(ev.Event) == "TransactionStatus":
            id = "TransactionMonitoring"
          else:
            if number: id = number
          if self.uniqClientID: id = id + " " + self.uniqClientID
          self.master.ActionOnUnexpectedEvent(id, ev)
          if ev.Event == EventName.Error and ev.ReferenceID and ev.ReferenceID == self.refID:
            timeout = 2
        # i not changed !!!

      else:
        i = i+1
    for ev1 in eventToPutBackList:
      self.PutBackEvent(ev1)
    if found:
      if GetOption("MT"):
        self.tsLock.release()
      return ev
    else:
      # Wait event from T-Server
      ev = None
      eventToPutBackList = []
      startedAt = time.time()
      while (not ev):

        if time.time() > startedAt + timeout:
          break
        if self.fd == -1: #could be set in connection error
          break
        if GetOption("MT"): TLock.acquire()
        rawEventSet = ReadEvent(self.fd, timeout, 0) # Wait T-Server event, Tlib call
        if GetOption("MT"): TLock.release()
        if not rawEventSet:

          break

        for rawEvent in rawEventSet:

          ev0 = Event(copy.deepcopy(rawEvent)) # Get Event

          #---Begin supplemental checking, printing etc on NEW event---


          if str(ev0.Event) in CallMonitoringEvents.members:
            PrintViewA(ev0.__repr__(), GetOption("TestResultFolder") + "\\AllCallMonitoring.txt")
          elif str(ev0.Event) == EventName.TransactionStatus:
            PrintViewA(ev0.__repr__(), GetOption("TestResultFolder") + "\\AllTransMononitoring.txt")

          if GetOption("TrackEvents"):
            if ev0.ThisDN and ev0.ConnID != NoConnID:
              connID = ConnIDToStr(ev0.ConnID)
              if not self.printBuffer.has_key(connID):
                self.printBuffer[connID] = ([], TestHandler())
              self.printBuffer[connID][0].append(ev0)
          if GetOption("TrackCallUUID"):
            if ev0.CallUUID and ev0.CallUUID not in self.callUUIDs:
              self.callUUIDs.append(ev0.CallUUID)
              PrintViewA(ev0.CallUUID, self.callUUIDsFileName)
          if ev0.ThisDN and ev0.ConnID != NoConnID and ev0.Event != EventName.UserEvent:
            if not self.allConnIDs.has_key(ev0.ConnID):
              self.allConnIDs[ev0.ConnID] = ev0

          if self.appVersion >= "7.2":
            if ev0.Event == EventName.PrimaryChanged:
              self.previousEventSequenceNumber = 0
              self.master.AfterSwitchover()

            if ev0.Event not in (EventName.ServerConnected, EventName.ServerDisconnected):
              if self.master:
                self.master.TestEventSequenceNumber(ev0, self.previousEventSequenceNumber)
              if ev0.EventSequenceNumber <> 18446744073709551615:
                self.previousEventSequenceNumber = ev0.EventSequenceNumber

          if ev0 and ev0.ThisDN:
            if ev0.Event in [EventName.Dialing, EventName.Ringing, EventName.Queued,
                           EventName.RouteRequest, EventName.PartyChanged, EventName.Retrieved]:
              if (ev0.ConnID <> NoConnID):
                self.setBeforeLastConnID(ev0.ThisDN, self.getLastConnID(ev0.ThisDN))
                self.setLastConnID(ev0.ThisDN, ev0.ConnID)

            if ev0.Event in [EventName.Released, EventName.Abandoned, EventName.Diverted,
                           EventName.RouteUsed]:
              if (ev0.ConnID <> NoConnID):
                self.setBeforeLastConnID(ev0.ThisDN, self.getLastConnID(ev0.ThisDN))
                self.setLastConnID(ev0.ThisDN, NoConnID)

            if self.callMonitoringDN and ev0.ThisDN == self.callMonitoringDN.number:
              if InFalse(GetOption("DiscardCMReleased")):
                if ev0.Event == EventName.Released:
                  if ev0.ConnID not in self.callMonitoringDN.releasedConnIDs:
                    self.callMonitoringDN.releasedConnIDs.append(ev0.ConnID)
                  #PrintLog(("\n    " + str(ev0)).replace("\n", "\n    "))

                if ev0.CallUUID:
                  self.callMonitoringDN.eventMap[ev0.CallUUID] = ev0
              pass

          if ev0.Event == "ServerConnected":
            self.connected = 1
          if ev0.Event == "ServerDisconnected":
            timeout = 0
            self.ConnectionError()
          elif ev0.Event == "LinkConnected":
            self.linkConnected = 1
          elif ev0.Event == "LinkDisconnected":
            self.linkConnected = 0
          elif ev0.Event == "Registered" and ev0.ThisDN not in self.registeredDNs:
            self.registeredDNs.append(ev0.ThisDN)
          elif ev0.Event == "Unregistered" and ev0.ThisDN in self.registeredDNs:
            self.registeredDNs.remove(ev0.ThisDN)
          #print "self.linkConnected = %s" %self.linkConnected

          #---End supplemental checking, printing etc on NEW event---


          for e in self.IgnoredEventList:
            if (e[0] == ev0.ThisDN) and (e[1] == ev0.Event):
              self.IgnoredEventList.remove(e)
              break                             # ev0 ignored

          else:
            condition = 1
            if ev:
              condition = 0
            else:
              for pair in pairs:
                number, keyField = pair
                res = getattr(ev0, keyField)

                if keyField == "Extensions" and res and number:
                  match = 1
                  for k in number.keys():
                    if not res.has_key(k):
                      match = 0
                    else:
                      if number[k] != res[k]:
                        match = 0


                number, keyField = pair
                if not ((number == None) or (number == getattr(ev0, keyField)) or (number == "Empty" and not getattr(ev0, keyField)) or (keyField == "Extensions" and match)):
                  condition = 0
                  break

            if ev0.Event == "LinkDisconnected" and ev0.Event not in eventName:
              condition = 1 # we need actionOnUnexpected
            if condition:
              if (not eventName) or (ev0.Event in eventName):
                ev = ev0
              else:  # unexpected event
                flagUnexpected = 1

                if ev0.Event in (EventName.RemoteConnectionSuccess, EventName.RemoteConnectionFailed, EventName.NetworkCallStatus):
                  eventToPutBackList.insert(0, ev0)
                  flagUnexpected = 0

                for pair in self.ignoreUnexpectedEventsOnDNs:
                  if pair[0] == number and pair[1] == ev0.Event:
                    flagUnexpected = 0
                    break

                if str(ev0.Event) in CallMonitoringEvents.members or str(ev0.Event) == "TransactionStatus" \
                  or str(ev0.Event) == "PrivateInfo" \
                  and ev0.Event not in eventName :
                  eventToPutBackList.insert(0, ev0)
                  flagUnexpected = 0
                  if str(ev0.Event) == "PrivateInfo": PrintLog("Real time - got PrivateInfo, %s, %s" %(self.fd, ev0.Extensions))

                if not isinstance(self.master, Any) and self.master.ActionOnUnexpectedEvent and flagUnexpected:
                  id = ""
                  if str(ev0.Event) in CallMonitoringEvents.members:
                    id = "CallMonitoring"
                  elif str(ev0.Event) == "TransactionStatus":
                    id = "TransactionMonitoring"
                  else:
                    if number: id = number
                  if self.uniqClientID: id = id + " " + self.uniqClientID
                  self.master.ActionOnUnexpectedEvent(id, ev0)
                  if ev0.Event == EventName.Error and ev0.ReferenceID == self.refID and Synchronizer().GetControlStatus() == Normal:
                    timeout = 2
            else:
              if not(self.callMonitoringDN and ev0.ThisDN == self.callMonitoringDN.number):
                self.eventQueue.append(ev0)
              elif GetOption('GetNextEventOnCMDN'):
                 self.eventQueue.append(ev0)
              else: pass

        time.sleep(0.02)
      for ev1 in eventToPutBackList:
        self.PutBackEvent(ev1)
      if GetOption("MT"):
        self.tsLock.release()
      return ev

  def ClearQueue(self):
    #print "clearQueue"
    self.eventQueue = []



  def WaitUnreadEvents(self, timeout = 0.5):
    buf = []

    if self.fd < 0: return
    while(1):
      ev = self.WaitEvent(timeout = timeout)

      if not ev: break
      else:
        if ev.Event in ("RemoteConnectionSuccess", "RemoteConnectionFailed") : buf.append(ev)
        else:
          if str(ev.Event) in CallMonitoringEvents.members:  id = "CallMonitoring"
          else: id = ev.ThisDN
          if not id: id = ""
          if self.uniqClientID: id = id + " " + self.uniqClientID
          if ev.Event == "CallDataChanged":
            pass # do nothing
          else:
            if self.master and self.master.ActionOnUnexpectedEvent:
              self.master.ActionOnUnexpectedEvent(id, ev)
    if buf:
      for ev in buf:
        self.PutBackEvent(ev)

  def WaitUnreadEventsAll(self, timeout = 1):
    if self.fd < 0: return

    while(1):
      ev = self.WaitEvent(timeout = timeout)

      if not ev: break
      else:
        if str(ev.Event) in CallMonitoringEvents.members:  id = "CallMonitoring"
        else: id = ev.ThisDN
        if not id: id = ""
        if self.uniqClientID: id = id + " " + self.uniqClientID
        if ev.Event == "CallDataChanged":
          pass # do nothing
        else:
          if self.master and self.master.ActionOnUnexpectedEvent:
            self.master.ActionOnUnexpectedEvent(id, ev)

  def PutBackEvent(self, event):
    """ Put event back to self.eventQueue - operation reverse to WaitEvent."""
    self.eventQueue.insert(0, event)


  def setRawMask(self):
    if self.fd == -1: return        #non-monitored tserver
    bitMask = [255]*T_MASK_LENGTH()
    for each in EventName.members:
      if each not in self.mask:
        bitMask[each/8] = bitMask[each/8]&~(1<<(each%8))
    inpMask = ""
    for each in range(0, T_MASK_LENGTH()):
      inpMask = inpMask+chr(bitMask[each])
    res = TSetInputMask(self.fd, inpMask)
    if res < 0:                       # 0 is OK
      self.ConnectionError()
    return res


  def MaskSetAll(self):
    if self.fd == -1: return        #non-monitored tserver
    self.mask = EventName.members
    #self.refID = self.setRawMask()
    self.refID = TMaskSetAll(self.fd)
    self.WaitEvent(timeout = 1)
    return self.refID


  def MaskClearAll(self):
    if self.fd == -1: return        #non-monitored tserver
    self.mask = []
    #self.refID = self.setRawMask()
    self.refID = TMaskClearAll(self.fd)
    self.WaitEvent(timeout = 1)
    return self.refID


  def MaskSet(self, eventName, val):
    if val == 1:
      if eventName not in self.mask:
        self.mask.append(eventName)
    else:
      if eventName in self.mask:
        self.mask.remove(eventName)
    self.refID = self.setRawMask()
    return self.refID


  def MaskIsSet(self, eventName):
    return eventName in self.mask





#-----------------------------------------

  def SendUserEvent(self, number, event):
    if self.fd == -1:  return        #non-monitored tserver
    self.refID = TSendUserEvent(self.fd, number, event.rawEvent())
    if self.refID < 0:
      self.ConnectionError()

    return self.refID

  def SendEvent(self, event):
    self.refID = TSendEvent(self.fd,  event.rawEvent())
    if self.refID < 0:
      self.ConnectionError()
    return self.refID

  def SendEventEx(self, event, clientID):
    self.refID = TSendEventEx(self.fd,  event.rawEvent(), clientID)
    #if self.refID < 0:
    #  self.ConnectionError()
    return self.refID


  def RegisterAddress(self, number, registerMode = RegisterMode.Share, controlMode = ControlMode.Default,
                      addressType = AddressType.DN, extensions = None):
    if self.fd == -1: return        #non-monitored tserver

    if (Synchronizer().GetControlStatus() == Monitor) and (addressType == AddressType.RouteDN):
      time.sleep(3)
    self.refID = TRegisterAddress(self.fd, number, registerMode.val, controlMode.val, addressType.val, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def RegisterAll(self, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TRegisterAll(self.fd, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    self.registeredAll = 1
    return self.refID


  def UnregisterAll(self, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TUnregisterAll(self.fd, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    self.registeredAll = 0
    return self.refID


  def UnregisterAddress(self, number, controlMode = ControlMode.Default, extensions = None):
    if self.fd == -1:
      PrintLog("self.fd == -1")
      return
    if not self.numberRegistered(number):
      PrintLog("numberRegistered == 0")
      return        #non-monitored tserver
    self.refID = TUnregisterAddress(self.fd, number, controlMode.val, extensions)
    if self.refID <= 0:
      PrintLog("CONNECTION ERROR %s" %self.fd)
      self.ConnectionError()
    return self.refID


  def CallSetForward(self, number, destNumber, forwardMode = ForwardMode.Unconditional, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "CallSetForward"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TCallSetForward(self.fd, number, destNumber, forwardMode.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID



  def CallCancelForward(self, number, forwardMode = ForwardMode.Unconditional, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver

    c = "CallCancelForward"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:

      self.refID = TCallCancelForward(self.fd, number, forwardMode.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SetDNDOn(self, number, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver

    c = "SetDNDOn"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSetDNDOn(self.fd, number, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SetDNDOff(self, number, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver

    c = "SetDNDOff"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSetDNDOff(self.fd, number, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def MakeCall(self, number, dest, location = None, makeCallType = MakeCallType.Regular,
               userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver

    c = "MakeCall" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TMakeCall(self.fd, number, dest, location, makeCallType.val , userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def MakePredictiveCall(self, number, dest, ringTimeout = 0, userData = None,  reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver

    c = "MakePredictiveCall" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TMakePredictiveCall(self.fd, number, dest, ringTimeout, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def AnswerCall(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "AnswerCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAnswerCall(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def ReleaseCall(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ReleaseCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TReleaseCall(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def RouteCall(self, number, dest, connID = EmptyConnID, location = None, routeType = RouteType.Default,
                dnis = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "RouteCall" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TRouteCall(self.fd, number, connID, dest, location, routeType.val, dnis, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def HoldCall(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "HoldCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = THoldCall(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def RetrieveCall(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID:
      if self.getBeforeLastConnID(number) <> NoConnID:
        connID = self.getBeforeLastConnID(number)
      else:
        connID = self.getLastConnID(number)
    c = "RetrieveCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TRetrieveCall(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def AlternateCall(self, number, heldConnID = EmptyConnID, curConnID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if heldConnID ==  EmptyConnID: heldConnID = self.getBeforeLastConnID(number)
    if curConnID ==  EmptyConnID: curConnID = self.getLastConnID(number)
    c = "AlternateCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAlternateCall(self.fd, number, heldConnID, curConnID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()

    else:
      self.refID = -1
    return self.refID

  def ReconnectCall(self, number, heldConnID = EmptyConnID, curConnID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if heldConnID ==  EmptyConnID: heldConnID = self.getBeforeLastConnID(number)
    if curConnID ==  EmptyConnID: curConnID = self.getLastConnID(number)
    c = "ReconnectCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TReconnectCall(self.fd, number, heldConnID, curConnID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def RedirectCall(self, number, destNumber,  connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "RedirectCall" + destNumber
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TRedirectCall(self.fd, number, destNumber, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def InitiateTransfer(self, number, dest, connID = EmptyConnID, location = None, userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "InitiateTransfer" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TInitiateTransfer(self.fd, number, connID, dest, location, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def CompleteTransfer(self, number, mainConnID = EmptyConnID, consConnID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if mainConnID ==  EmptyConnID: mainConnID = self.getBeforeLastConnID(number)
    if consConnID ==  EmptyConnID: consConnID = self.getLastConnID(number)
    c = "CompleteTransfer"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TCompleteTransfer(self.fd, number, mainConnID, consConnID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def MuteTransfer(self, number, dest, connID = EmptyConnID, location = None, userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "MuteTransfer" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TMuteTransfer(self.fd, number, connID, dest, location, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SingleStepTransfer(self, number, dest, connID = EmptyConnID, location = None, userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "SingleStepTransfer" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSingleStepTransfer(self.fd, number, connID, dest, location, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SingleStepConference(self, number, dest, connID = EmptyConnID, location = None, userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "SingleStepConference" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSingleStepConference(self.fd, number, connID, dest, location, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def InitiateConference(self, number, dest, connID = EmptyConnID, location  = None, userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "InitiateConference" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TInitiateConference(self.fd, number, connID, dest, location, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def CompleteConference(self, number, mainConnID = EmptyConnID, consConnID = EmptyConnID,  reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if mainConnID ==  EmptyConnID: mainConnID = self.getBeforeLastConnID(number)
    if consConnID ==  EmptyConnID: consConnID = self.getLastConnID(number)
    c = "CompleteConference"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TCompleteConference(self.fd, number, mainConnID, consConnID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def DeleteFromConference(self, number, destNumber, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "DeleteFromConference" + destNumber
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TDeleteFromConference(self.fd, number, destNumber, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def MergeCalls(self, number, mainConnID = EmptyConnID, consConnID = EmptyConnID,
                  mergeType = MergeType.Transfer, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if mainConnID ==  EmptyConnID: mainConnID = self.getBeforeLastConnID(number)
    if consConnID ==  EmptyConnID: consConnID = self.getLastConnID(number)
    c = "MergeCalls"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TMergeCalls(self.fd, number, mainConnID, consConnID, mergeType.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID


  def ClearCall(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ClearCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TClearCall(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def AgentLogin(self, queue, number, agentID, agentType = AgentType.Agent, passwd = "",
       workMode  = AgentWorkMode.Unknown, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "AgentLogin" + queue
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if passwd:
      passwd = str(passwd)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAgentLogin(self.fd, queue, number, agentType.val, agentID, passwd, workMode.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def AgentLogout(self, queue, number, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "AgentLogout" + queue
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAgentLogout(self.fd, queue, number, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID




  def AgentSetReady(self, queue, number, workMode = AgentWorkMode.AutoIn, reasons = None,
                    extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "AgentSetReady" + queue
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAgentSetReady(self.fd, queue, number, workMode.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def AgentSetNotReady(self, queue, number, workMode = AgentWorkMode.AuxWork, reasons = None,
                       extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "AgentSetNotReady" + queue
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TAgentSetNotReady(self.fd, queue, number, workMode.val, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def QueryAddress(self, queue, number, addrType, infoType, extensions = None):
    if self.fd == -1: return        #non-monitored tserver

    self.refID = TQueryAddress(self.fd, queue, number, addrType.val, infoType.val, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID



  def QueryLocation(self, location, infoType, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TQueryLocation(self.fd, location, infoType.val, extensions)#infoType.val
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID



  def AttachUserData(self, number, connID = EmptyConnID, userData = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "AttachUserData"
    Synchronizer().ExchangeCommands(c)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TAttachUserData(self.fd, number, connID, userData)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def UpdateUserData(self, number, connID = EmptyConnID, userData = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID:
      connID = self.getLastConnID(number)
    c = "UpdateUserData"
    Synchronizer().ExchangeCommands(c)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TUpdateUserData(self.fd, number, connID, userData)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def DeleteUserData(self, number, connID = EmptyConnID, key = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "DeleteUserData"
    Synchronizer().ExchangeCommands(c)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TDeleteUserData(self.fd, number, connID, key)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def DeleteAllUserData(self, number, connID = EmptyConnID):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "DeleteAllUserData"
    Synchronizer().ExchangeCommands(c)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TDeleteAllUserData(self.fd, number, connID)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def ApplyTreatment(self, number, connID = EmptyConnID, treatment = TreatmentType.Silence,
                    parameters = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ApplyTreatment"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TApplyTreatment(self.fd, number, connID, treatment.val, parameters, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def GiveMusicTreatment(self, number, musicDn, connID = EmptyConnID,   reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "GiveMusicTreatment"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TGiveMusicTreatment(self.fd, number, connID, musicDn,  reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def GiveSilenceTreatment(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "GiveSilenceTreatment"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TGiveSilenceTreatment(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def GiveRingBackTreatment(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "GiveRingBackTreatment"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TGiveRingBackTreatment(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def LoginMailBox(self, voiceDn, mboxNumber, mboxPasswd, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "LoginMailBox" + voiceDn
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TLoginMailBox(self.fd, voiceDn, mboxNumber, mboxPasswd, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def LogoutMailBox(self, voiceDn, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "LogoutMailBox" + voiceDn
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TLogoutMailBox(self.fd, voiceDn, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def OpenVoiceFile(self, number, fileName, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "OpenVoiceFile" + number
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TOpenVoiceFile(self.fd, number, fileName, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def CloseVoiceFile(self, number, fileHandle, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "CloseVoiceFile" + number
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TCloseVoiceFile(self.fd, number, fileHandle, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def ListenDisconnect(self, number, listenerNumber, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ListenDisconnect" + listenerNumber
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TListenDisconnect(self.fd, number,listenerNumber, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def ListenReconnect(self, number, listenerNumber, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ListenReconnect" + listenerNumber
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TListenReconnect(self.fd, number,listenerNumber, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SetReferenceID(self, refID):
    self.refID = TSetReferenceID(refID)
    return self.refID



  def GetAccessNumber(self, number, dest, connID = EmptyConnID, location = None, routeType = XRouteType.XRouteTypeDefault,
                userData = None, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "GetAccessNumber" + dest
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) :
      self.refID = TGetAccessNumber(self.fd, number, connID, dest, location, routeType.val, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def CancelReqGetAccessNumber(self, refID):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TCancelReqGetAccessNumber(self.fd, refID)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def ReserveAgent(self, agentDn = "", agentId = "",  agentPlace = "", duration = -1,
                  priority = -1, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    c = "ReserveAgent" + agentDn
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TReserveAgent(self.fd, agentDn, agentId, agentPlace, duration, priority, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID


  def ReserveAgentAndGetAccessNumber(self, agentDn = "", agentId = "",  agentPlace = "", duration = -1,
                  priority = -1, connID = EmptyConnID, xRouteType = XRouteType.XRouteTypeDefault,
                  userData = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "ReserveAgentAndGetAccessNumber"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)):
      self.refID = TReserveAgentAndGetAccessNumber(self.fd, agentDn, agentId, agentPlace, duration, priority, connID, xRouteType.val, userData, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def QueryServer(self, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TQueryServer(self.fd,  extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def QueryCall(self, number, connID = EmptyConnID, infoType = CallInfoType.CallInfoStatusQuery, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TQueryCall(self.fd,  number, connID, infoType.val, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def PrivateService(self, messageID, number, connID = EmptyConnID, userData = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    reasons = Reasons(reasons)
    self.refID = TPrivateService(self.fd, messageID, number, connID,  userData, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def StartCallMonitoring(self, regMode = TRegMode.RegModeDefault, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TStartCallMonitoring(self.fd, regMode.val, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def StopCallMonitoring(self, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TStopCallMonitoring(self.fd, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def SetMessageWaitingOn(self, number, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "SetMessageWaitingOn"
    Synchronizer().ExchangeCommands(c)
    self.refID = TSetMessageWaitingOn(self.fd, number, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def SetMessageWaitingOff(self, number, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "SetMessageWaitingOff"
    Synchronizer().ExchangeCommands(c)
    self.refID = TSetMessageWaitingOff(self.fd, number, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def MonitorNextCall(self, number, agentNumber, monitorType = MonitorNextCallType.MonitorOneCall, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "MonitorNextCall"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    self.refID = TMonitorNextCall(self.fd, number, agentNumber, monitorType.val, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def CancelMonitoring(self, number, agentNumber, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    c = "CancelMonitoring"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    self.refID = TCancelMonitoring(self.fd, number, agentNumber, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def QuerySwitch(self, infoType = SwitchInfoType.SwitchInfoDateTime, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    self.refID = TQuerySwitch(self.fd, infoType.val, extensions)#infoType.val
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def SendDTMF(self, number, connID = EmptyConnID, digits = "", reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "SendDTMF"
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSendDTMF(self.fd, number, connID, digits, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def NetworkConsult(self, number, dest, connID = EmptyConnID, homeLocation = None, destLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkConsult(self.fd, number, connID, homeLocation, dest, destLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def NetworkAlternate(self, number, connID = EmptyConnID, homeLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkAlternate(self.fd, number, connID, homeLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def NetworkTransfer(self, number, connID = EmptyConnID, homeLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkTransfer(self.fd, number, connID, homeLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def NetworkMerge(self, number, connID = EmptyConnID, homeLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkMerge(self.fd, number, connID, homeLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def NetworkReconnect(self, number, connID = EmptyConnID, homeLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkReconnect(self.fd, number, connID, homeLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def NetworkSingleStepTransfer(self, number, dest, connID = EmptyConnID, homeLocation = None, destLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkSingleStepTransfer(self.fd, number, connID, homeLocation, dest, destLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def NetworkPrivateService(self, serviceID, number, connID = EmptyConnID, homeLocation = None, reasons = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    self.refID = TNetworkPrivateService(self.fd, serviceID, number, connID, homeLocation, reasons, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID


  def SetCallAttributes(self, op = SetOpType.SetCallInfo, connID = EmptyConnID, newConnID = NoConnID, origination = None, destination = None, extensions = None):
    if self.fd == -1: return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(origination)
    self.refID = TSetCallAttributes(self.fd, op.val, connID, newConnID, origination, destination, extensions)
    if self.refID <= 0:
      self.ConnectionError()
    return self.refID

  def SetMuteOn(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "SetMuteOn" + number
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSetMuteOn(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def SetMuteOff(self, number, connID = EmptyConnID, reasons = None, extensions = None):
    if self.fd == -1 or not self.numberRegistered(number): return        #non-monitored tserver
    if connID ==  EmptyConnID: connID = self.getLastConnID(number)
    c = "SetMuteOn" + number
    Synchronizer().ExchangeCommands(c)
    reasons = Reasons(reasons)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TSetMuteOff(self.fd, number, connID, reasons, extensions)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID

  def TransactionMonitoring(self, subscriptionOperation, subscriptionIdentifier = None, subscriptionRules = None):
    if self.fd == -1 :return        #non-monitored tserver
    c = "TransactionMonitoring"
    Synchronizer().ExchangeCommands(c)
    if (Synchronizer().GetControlStatus() not in (Monitor, Passive)) and self.linkConnected:
      self.refID = TTransactionMonitoring(self.fd, subscriptionOperation.val, subscriptionIdentifier, subscriptionRules)
      if self.refID <= 0:
        self.ConnectionError()
    else:
      self.refID = -1
    return self.refID


  def KVListToString(self, kvList):
    return TKVListToString(kvList)

  def GetXCapsFromString(self, extendedCapatibilities, capType, subtype):
    if type(capType) != type(0):
      capType = capType.val
    if type(subtype) != type(0):
      subtype = subtype.val
    return TGetXCapsFromString(extendedCapatibilities, capType, subtype)

  def GetXCapsFromKVList(self, extendedCapatibilities, capType, subtype):
    if type(capType) != type(0):
      capType = capType.val
    if type(subtype) != type(0):
      subtype = subtype.val
    return TGetXCapsFromKVList(extendedCapatibilities, capType, subtype)

  def GetCapsFromKVList(self, capatibilities, mask):
    return TGetCapsFromKVList(capatibilities, mask)

